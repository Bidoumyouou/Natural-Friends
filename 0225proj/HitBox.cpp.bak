#include"HitBox.h"
#include"Camera.h"
#include"Player.h"
#include"GameMgr.h"


C_HitBox::C_HitBox(int arynum) : ObjectBase(arynum){
	exi[arraynum] = true;
	object_n++;
	id = total;
	total++;
	///////////////
}

C_HitBox::~C_HitBox()
{
	exi[arraynum] = false;
	object_n--;
}

void C_HitBox::Process()
{
	if (!initflag) { Init(); initflag = 1; }
	
	p_id = 0;

	//状態変化の瞬間に
	if (Hitmode != Next_Hitmode) {
		state_t = 0;
	}
	else { state_t++; }
	//状態変化
	Pre_Hitmode = Hitmode;
	Hitmode = Next_Hitmode;
	player->hitbox_exi[Pre_Hitmode] = false;
	player->hitbox_exi[Hitmode] = true;
	if (!initflag) { ObjectBase::Init(); Init(); initflag = true; }
	//状態によって分岐
	switch(Hitmode) {
	case H_SLASH:Slash(); break;
	case H_SLASHCHARGE:SlashCharge(); break;
	case H_DEFENCE:Defence(); break;
	case H_SHOT:Shot(); break;
		//case H_NONE:None(); break;
	case H_COUNTER:Counter(); break;
	case H_NONE:None(); break;
	}
	

	//森絶対座標と相対座標の統一
	
	if ( Hitmode > 0 && Hitmode <= H_HitMode_N - 1) {
		//プレイヤーのposを保存
		if (player != nullptr) {
			p_pos = m_GameMgr->p_pos[p_gid[arraynum]];
		}
		if (Hitmode == H_SHOT) {
			//プレイヤーの座標に依存しない

		}
		else {
			//プレイヤーの座標に依存
			//abs_area.v[0] = area.v[0] + p_pos;
			//abs_area.v[1] = area.v[1] + p_pos;
			abs_area.Set2p(area.v[0].x + p_pos.x, area.v[0].y + p_pos.y, area.v[1].x + p_pos.x, area.v[1].y + p_pos.y);
		}
	}
}

void C_HitBox::HitCheck() {

}

void C_HitBox::Draw()
{
	switch (Hitmode) {
	case H_SLASHCHARGE:BoxColor = RED; break;
	case H_SLASH:BoxColor = BLUE; break;
	case H_SHOT:BoxColor = GREEN; break;
	case H_COUNTER:BoxColor = YELLOW; break;
	case H_DEFENCE:BoxColor = PURPLE; break;
	default:BoxColor = PURPLE; break;
	}

	//DrawBox(pos.x - Camera.UpperLeft_pos.x + player->pos.x, pos.y + player->pos.y, pos.x + player->pos.x + 50 - Camera.UpperLeft_pos.x, pos.y + player->pos.y + 50, BoxColor, 1);
	if (DEBUG) {
		//DrawBox(area.v[0].x - Camera.UpperLeft_pos.x + player->pos.x, area.v[0].y + player->pos.y, area.v[1].x - Camera.UpperLeft_pos.x + player->pos.x, area.v[1].y + player->pos.y, BoxColor, 1);
		DrawBox(abs_area.v[0].x - Camera.UpperLeft_pos.x , abs_area.v[0].y, abs_area.v[1].x - Camera.UpperLeft_pos.x , abs_area.v[1].y , BoxColor, 1);
	}

}

void C_HitBox::Init()
{
    p_gid[arraynum] =  player->playerid;
	//HitBoxインスタンスを呼び出したPlayerインスタンスのポインタを記憶
	for (int i = 0; i < PLAYER_HITBOX_MAX; i++){
		//if (player->hitbox[i] == nullptr) {
		//	player->hitbox[i] = this;
		//}
		//pos.Set(200, 100);
	}
}

void C_HitBox::Exit()
{
}

void C_HitBox::None()
{
	//自動的に破棄
	C_HitBox::Delete(arraynum);
}

void C_HitBox::Defence()
{
	
	//範囲内に攻撃が入ったら
	//全てのヒットボックスに対して
	for (int i = 0; i < C_HitBox::object_n; i++) {
		//ヒットボックスの種類が攻撃系だったら
		if (HitBox[i]->Hitmode == H_SHOT || HitBox[i]->Hitmode == H_SLASH) {
			//ヒットボックスが相手プレイヤーのものだったら
			if (HitBox[i]->player->playerid != player->playerid) {
				//攻撃を仕掛けたヒットボックスのポインタを入手
				//ヒットボックスが座標内に入っていたら
				for (int j = 0; j < 4; j++) {
					//当たり判定ガバいので直す
					if (HitBox[i]->abs_area.inSquare(abs_area.v[j])){
						HitBox[i]->isHit = true;
						player->Next_State = DAMEGE;
						break;

					}
				}
			}
		}
	}

	
}

void C_HitBox::SlashCharge()
{
	slash_t++;
	//チャージの長さに応じたあたり判定の大きさの変更
	if (slash_t >= 0 && slash_t < 15) {
		slash_level = 0;
	}
	else if(slash_t >= 15 && slash_t < 30){
		slash_level = 1;

	}
	else {
		slash_level = 2;
	}
}

void C_HitBox::Slash()
{
	int i;
	if (player->direction == 1)
		i = 1;
	else
		i = 0;

	//長さが貯めた量の規定以上になったら
	if ((slash_level + 1) * 150 < abs(area.v[i].x)) {
		slash_state = 1;
	}

	//実際にあたり判定を伸ばす
	if (slash_state == 0) {
		Vector2 tmp = area.v[i];
		tmp.x += SLASH_SPEED * player->direction;
		//pos_v.Set2p(pos_v.v[0], tmp);
		if (i == 1)
			area.Set2p(area.v[0], tmp);
		else if (i == 0)
			area.Set2p(tmp, area.v[1]);
	}
	//縮める
	if (slash_state == 1) {
		Vector2 tmp = area.v[i];
		tmp.x -= (SLASH_SPEED / 2) * player->direction;
		//pos_v.Set2p(pos_v.v[0], tmp);
		if (i == 1)
			area.Set2p(area.v[0], tmp);
		else if (i == 0)
			area.Set2p(tmp, area.v[1]);
	}

	if (player->direction == 1) {
		if (area.v[1].x < 0) {
			Next_Hitmode = H_NONE;
		}
	}
	else if (player->direction == -1) {
		if (area.v[0].x > 0) {
			Next_Hitmode = H_NONE;
		}
	}


}

void C_HitBox::Shot()
{
	if (Pre_Hitmode == H_NONE) {
		area.v[0].x += SHOT_RANGE * player->direction;
		area.v[1].x += SHOT_RANGE * player->direction;
		area.v[0].y += PLAYERHEIGHT / 2; //プレイヤーの中心点座標分下げる
		area.v[1].y += PLAYERHEIGHT / 2;
		area.Set2p(area.v[0], area.v[1]);
	}

	/*if (area.v[0].y > -SHOT_HEIGHT) {
		area.v[0].y -= SHOT_SPEED;
		area.Set2p(area.v[0], area.v[1]);
	}*/
	if (state_t < SHOT_WAIT) {
		;
	}
	else if (state_t == SHOT_WAIT) {
		area.v[0].y -= (SHOT_HEIGHT / 2);
		area.Set2p(area.v[0], area.v[1]);
	}
	else if (state_t < SHOT_WAIT + SHOT_TIME) {
		;
	}
	else {
		Next_Hitmode = H_NONE;
	}
}

void C_HitBox::Counter()
{
	if (state_t < COUNTER_WAIT) {
		;
	}
	else if (state_t == COUNTER_WAIT) {
		area.v[0].x = -(PLAYERWIDTH / 4);
		area.v[1].x = +(PLAYERWIDTH / 4);
		area.v[0].y = -(PLAYERHEIGHT / 4); //プレイヤーの中心点座標分下げる
		area.v[1].y = +(PLAYERHEIGHT / 4);
		area.Set2p(area.v[0], area.v[1]);
	}
	else if (state_t < COUNTER_WAIT + COUNTER_TIME) {
		;
	}
	else {
		Next_Hitmode = H_NONE;
	}
}

void C_HitBox::AllProcess()
{
	for (int i = 0; i < total; i++) {
		if (C_HitBox::exi[i]) {
			if (C_HitBox::exi[i] == true)
				HitBox[i]->Process();
		}
	}
}

void C_HitBox::AllDraw()
{
	for (int i = 0; i < total; i++) {
		if (C_HitBox::exi[i]) {
			if (C_HitBox::exi[i] == true)
				HitBox[i]->Draw();
		}
	}
}

void C_HitBox::AllDelete()
{
	for (int i = 0; i < PLAYER_MAX; i++) {
		if (C_HitBox::exi[i] == true) {
			delete HitBox[i];
		}
	}
}

void C_HitBox::Make()
{
	for (int i = 0; i < object_n + 1; i++) {
		if (C_HitBox::exi[i] == 0) {
			HitBox[i] = new C_HitBox(i);
			return;
		}
	}
}

int C_HitBox::Make2()
{
	for (int i = 0; i < object_n + 1; i++) {
		if (C_HitBox::exi[i] == 0) {
			HitBox[i] = new C_HitBox(i);
			return i;
		}
	}
}

void C_HitBox::Delete(int i)
{
	if (C_HitBox::object_n > 0) {
		delete HitBox[i];
	}
}

int C_HitBox::GetObject_n()
{
	return 0;
}

int C_HitBox::total = 0;
int C_HitBox::object_n = 0;//静的メンバ変数の実体
bool C_HitBox::exi[PLAYER_MAX] = {};

int p_gid[64];
C_HitBox *HitBox[64];

